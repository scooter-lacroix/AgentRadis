# Identity Framework Usage Guide

This guide provides comprehensive examples and best practices for using the Identity Framework within your Radis-powered applications.

## Table of Contents
- [Basic Usage with EnhancedRadis](#basic-usage-with-enhancedradis)
- [Advanced Configuration Options](#advanced-configuration-options)
- [Custom Identity Rules](#custom-identity-rules)
- [Error Handling and Logging](#error-handling-and-logging)
- [Integration with Existing Systems](#integration-with-existing-systems)
- [Best Practices](#best-practices)

## Basic Usage with EnhancedRadis

The Identity Framework is integrated into the EnhancedRadis class to provide seamless identity management and validation.

### Installation

```python
# Import the necessary components
from app.agent.enhanced_radis import EnhancedRadis
from app.agent.identity_context import RadisIdentityContext
from app.agent.response_processor import ResponseProcessor
```

### Simple Example

```python
# Initialize EnhancedRadis with default settings
radis_agent = EnhancedRadis()

# Process a user query
response = radis_agent.run("What AI model are you based on?")

# The response will automatically have any references to other models
# replaced with "Radis" through the identity framework
print(response)  # Output will refer to Radis, not GPT, Claude, etc.
```

### Working with the Identity Context

```python
from app.agent.identity_context import RadisIdentityContext

# Create an identity context with a specific project root
identity_context = RadisIdentityContext(project_root="/path/to/project")

# Track command execution
identity_context.add_command("ls -la", success=True)

# Validate a working directory change
if identity_context.validate_directory_change("/path/to/project/subdir"):
    print("Directory change is within project boundaries")
else:
    print("Directory change would exit project boundaries")
```

### Using Response Processor Directly

```python
from app.agent.response_processor import ResponseProcessor

# Initialize the processor
processor = ResponseProcessor()

# Sanitize a response that might contain references to other AI models
original_text = "This analysis was generated by GPT-4, an AI model by OpenAI."
sanitized_text = processor.sanitize_response(original_text)
print(sanitized_text)  # Output: "This analysis was generated by Radis, an AI model by Radis."
```

## Advanced Configuration Options

The Identity Framework provides several configuration options for customizing its behavior.

### Configuring EnhancedRadis with Custom Identity Settings

```python
from app.agent.enhanced_radis import EnhancedRadis, RadisConfig, SecurityConfig

# Create custom configurations
security_config = SecurityConfig(
    enforce_path_boundaries=True,
    allow_external_tools=False,
    max_command_history=100,
    sensitive_terms=["password", "token", "key"],
    block_system_commands=True
)

radis_config = RadisConfig(
    model="latest",
    temperature=0.7,
    security=security_config,
    project_root="/path/to/project",
    sanitize_responses=True,
    log_level="INFO"
)

# Initialize with custom configuration
radis_agent = EnhancedRadis(config=radis_config)
```

### Customizing the Response Processor

```python
from app.agent.response_processor import ResponseProcessor, ModelNameDetector
from app.agent.identity_context import RadisIdentityContext

# Create a custom model name detector with additional patterns
custom_detector = ModelNameDetector(
    additional_patterns=[
        r"Palm(?:\s*AI)?",  # Detect references to Palm AI
        r"Gemini(?:\s*[Pp]ro)?",  # Detect references to Gemini
        r"Custom\s*AI\s*Model"  # Detect a custom AI model reference
    ]
)

# Create a response processor with the custom detector
processor = ResponseProcessor(model_detector=custom_detector)

# Use the processor with EnhancedRadis
identity_context = RadisIdentityContext(project_root="/path/to/project")
radis_agent = EnhancedRadis(
    identity_context=identity_context,
    response_processor=processor
)
```

### Path Validation Configuration

```python
from app.agent.response_processor import PathValidator

# Create a custom path validator with specific rules
validator = PathValidator(
    allowed_roots=["/path/to/project", "/path/to/data"],
    blocked_patterns=[r".*\.secret", r".*\.key", r".*password.*"],
    max_symlink_depth=3
)

# Use the validator with a response processor
processor = ResponseProcessor(path_validator=validator)
```

## Custom Identity Rules

You can create and apply custom identity rules to enforce specific behavior.

### Creating Custom Identity Rules

```python
from app.agent.identity_context import RadisIdentityRule, RadisIdentityContext

# Define a custom identity rule
class NoExecutablesRule(RadisIdentityRule):
    def validate(self, content, context=None):
        """Prevent execution of .exe, .sh, and other executable files."""
        executable_patterns = [r"\.exe$", r"\.sh$", r"\.bat$", r"\.cmd$"]
        for pattern in executable_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return False, f"Execution of {content} is not allowed by security policy"
        return True, None

# Create a custom context with this rule
context = RadisIdentityContext()
context.add_rule(NoExecutablesRule())

# Use in validation
is_valid, message = context.validate_command("run malicious.exe")
if not is_valid:
    print(f"Command rejected: {message}")
```

### Implementing Organization-Specific Rules

```python
# Define a rule for corporate compliance
class CorporateComplianceRule(RadisIdentityRule):
    def __init__(self, compliance_patterns):
        self.compliance_patterns = compliance_patterns
        
    def validate(self, content, context=None):
        """Check content against corporate compliance patterns."""
        for pattern, message in self.compliance_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return False, f"Compliance violation: {message}"
        return True, None

# Example usage with company-specific rules
compliance_patterns = [
    (r"confidential|classified", "Cannot discuss confidential information"),
    (r"competitor\s*data", "Cannot access competitor data"),
    (r"financial\s*report", "Financial reports require proper authorization")
]

corporate_rule = CorporateComplianceRule(compliance_patterns)
context = RadisIdentityContext()
context.add_rule(corporate_rule)
```

## Error Handling and Logging

Proper error handling and logging are essential for maintaining security and debugging issues.

### Handling Identity Validation Errors

```python
from app.errors import IdentityValidationError, CommandExecutionError

try:
    # Attempt to run a command that might violate identity rules
    result = radis_agent.run_command("rm -rf /", working_dir="/path/to/project")
except IdentityValidationError as e:
    # Handle identity validation errors
    print(f"Identity validation failed: {e}")
    # Log the error for security auditing
    logger.warning(f"Identity validation error: {e}", extra={"security_event": True})
except CommandExecutionError as e:
    # Handle command execution errors
    print(f"Command execution failed: {e}")
    # Log with relevant context
    logger.error(f"Command failed: {e}", extra={"command": e.command, "exit_code": e.exit_code})
```

### Logging Identity Framework Events

```python
import logging
from app.logger import setup_logger

# Set up logger with identity framework handlers
logger = setup_logger(
    "identity_framework", 
    log_level=logging.INFO,
    log_file="/path/to/identity_events.log",
    include_security_events=True
)

# Use the logger with the identity framework
identity_context = RadisIdentityContext(logger=logger)

# Log specific identity events
def process_with_logging(user_input):
    logger.info(f"Processing user input", extra={"input_length": len(user_input)})
    try:
        result = radis_agent.run(user_input)
        logger.info("Processing successful", extra={
            "sanitization_applied": True,
            "response_length": len(result)
        })
        return result
    except Exception as e:
        logger.error(f"Processing failed: {e}", exc_info=True)
        raise
```

### Creating a Comprehensive Logging System

```python
# Configure a comprehensive logging setup
import logging
from app.logger import setup_security_logger

# Setup different loggers for different purposes
command_logger = setup_security_logger("command_history", "/path/to/logs/commands.log")
identity_logger = setup_security_logger("identity_events", "/path/to/logs/identity.log")
security_logger = setup_security_logger("security_events", "/path/to/logs/security.log")

# Use loggers in different components
identity_context = RadisIdentityContext(logger=identity_logger)
response_processor = ResponseProcessor(logger=security_logger)

# Example of logging a security event
def log_security_event(event_type, details, severity="INFO"):
    log_data = {
        "event_type": event_type,
        "timestamp": datetime.now().isoformat(),
        "details": details,
        "severity": severity
    }
    security_logger.info(f"Security event: {event_type}", extra=log_data)

# Usage
log_security_event("identity_validation", {
    "rule": "model_reference_detection",
    "original_text": "Generated by GPT-4",
    "sanitized_text": "Generated by Radis"
})
```

## Integration with Existing Systems

The Identity Framework can be integrated with various existing systems.

### Integration with Web Applications

```python
# Example integration with a Flask web application
from flask import Flask, request, jsonify
from app.agent.enhanced_radis import EnhancedRadis

app = Flask(__name__)
radis_agent = EnhancedRadis(project_root=app.root_path)

@app.route("/ask", methods=["POST"])
def ask_radis():
    user_query = request.json.get("query", "")
    context = request.json.get("context", {})
    
    try:
        # Process the query through Radis with identity validation
        response = radis_agent.run(user_query, context=context)
        return jsonify({"success": True, "response": response})
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 400

if __name__ == "__main__":
    app.run(debug=True)
```

### Integration with CI/CD Pipelines

```python
# Example GitHub Actions workflow step
def validate_code_with_identity_framework(code_files):
    """Validate code changes using the identity framework."""
    from app.agent.identity_context import RadisIdentityContext
    from app.agent.response_processor import ResponseProcessor
    
    # Initialize the identity validation components
    context = RadisIdentityContext(project_root=os.getcwd())
    processor = ResponseProcessor()
    
    # Check each file for identity compliance
    violations = []
    for file_path in code_files:
        with open(file_path, 'r') as f:
            content = f.read()
            
        # Check for violations of identity rules
        is_valid, message = processor.validate_content(content)
        if not is_valid:
            violations.append(f"{file_path}: {message}")
    
    # Return validation results
    return len(violations) == 0, violations

# Usage in a CI script
if __name__ == "__main__":
    import sys
    import glob
    
    # Get all Python files
    python_files = glob.glob("**/*.py", recursive=True)
    
    # Validate files
    is_valid, violations = validate_code_with_identity_framework(python_files)
    
    # Print results
    for violation in violations:
        print(f"VIOLATION: {violation}")
    
    # Exit with appropriate code
    sys.exit(0 if is_valid else 1)
```

### Integration with Command-Line Tools

```python
import argparse
from app.agent.enhanced_radis import EnhancedRadis

def main():
    parser = argparse.ArgumentParser(description="Radis CLI with Identity Framework")
    parser.add_argument("query", help="Query to process")
    parser.add_argument("--project", help="Project root directory")
    parser.add_argument("--strict", action="store_true", help="Enable strict identity validation")
    args = parser.parse_args()
    
    # Initialize Radis with identity framework
    radis = EnhancedRadis(
        project_root=args.project or os.getcwd(),
        strict_validation=args.strict
    )
    
    # Process the query
    try:
        response = radis.run(args.query)
        print(response)
    except Exception as e:
        print(f"Error: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    import sys
    sys.exit(main())
```

## Best Practices

Follow these best practices to get the most out of the Identity Framework:

### Security Best Practices

1. **Always Use Path Validation**

```python
# GOOD: Always use path validation
from app.agent.response_processor import PathValidator

validator = PathValidator(project_root="/path/to/project")
result = validator.validate_path(user_supplied_path)
if not result.is_valid:
    print(f"Invalid path: {result.message}")
    return

# Process the validated path
with open(result.safe_path, 'r') as f:
    content = f.read()
```

2. **Enable Command Tracking**

```python
# GOOD: Track all commands for audit purposes
from app.agent.identity_context import RadisIdentityContext

context = RadisIdentityContext()

# Before executing any command
context.add_command(command, working_dir=os.getcwd())

# After execution
context.update_last_command_status(success=True, output=output)

# Periodically save command history for audit purposes
context.save_command_history("/path/to/command_history.log")
```

3. **Use Strict Mode for Sensitive Operations**

```python
# GOOD: Use strict mode for sensitive operations
radis_agent = EnhancedRadis(strict_mode=True)

# For less sensitive operations, you can disable strict mode for specific calls
response = radis_agent.run_with_options(
    "Generate some creative ideas",
    strict_mode=False,
    allow_external_references=True
)
```

### Performance Best Practices

1. **Cache Validation Results When Appropriate**

```python
# Cache validation results for frequently used paths
from functools import lru_cache

class CachingPathValidator(PathValidator):
    @lru_cache(maxsize=100)
    def validate_path(self, path):
        return super().validate_path(path)
```

2. **Use Targeted Sanitization for Large Responses**

```python
# For large responses, use targeted sanitization
def process_large_response(large_text):
    # Find sections likely to contain model references
    potential_sections = [
        section for section in large_text.split('\n\n')
        if any(term in section.lower() for term in ['model', 'gpt', 'ai', 'claude'])
    ]
    
    # Only sanitize those sections
    processor = ResponseProcessor

